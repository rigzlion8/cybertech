"""
Vulnerability Scanner Module
Tests for common web vulnerabilities
"""

import requests
import logging
from urllib.parse import urljoin, urlparse, parse_qs
from bs4 import BeautifulSoup
import re

logger = logging.getLogger(__name__)


class VulnerabilityScanner:
    """Web vulnerability scanner"""
    
    # SQL Injection test payloads
    SQL_PAYLOADS = [
        "' OR '1'='1",
        "' OR '1'='1' --",
        "' OR '1'='1' /*",
        "admin' --",
        "1' OR '1'='1",
        "' UNION SELECT NULL--"
    ]
    
    # XSS test payloads
    XSS_PAYLOADS = [
        "<script>alert('XSS')</script>",
        "<img src=x onerror=alert('XSS')>",
        "<svg/onload=alert('XSS')>",
        "javascript:alert('XSS')",
        "<iframe src='javascript:alert(1)'>",
    ]
    
    # SQL error patterns
    SQL_ERRORS = [
        r"SQL syntax.*MySQL",
        r"Warning.*mysql_.*",
        r"MySQLSyntaxErrorException",
        r"valid MySQL result",
        r"PostgreSQL.*ERROR",
        r"Warning.*pg_.*",
        r"valid PostgreSQL result",
        r"Npgsql\.",
        r"Microsoft SQL Native Client error",
        r"ODBC SQL Server Driver",
        r"SQLServer JDBC Driver",
        r"Oracle error",
        r"Oracle.*Driver",
        r"Warning.*oci_.*",
    ]
    
    def __init__(self, target, timeout=10):
        self.target = target
        self.timeout = timeout
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        
    def scan(self):
        """Perform vulnerability scan"""
        results = {
            'target': self.target,
            'vulnerabilities': [],
            'sql_injection': [],
            'xss': [],
            'csrf': [],
            'other': [],
            'score': 100
        }
        
        try:
            # Test for SQL injection
            logger.info("Testing for SQL injection...")
            sql_vulns = self._test_sql_injection()
            if sql_vulns:
                results['sql_injection'] = sql_vulns
                results['vulnerabilities'].extend(sql_vulns)
            
            # Test for XSS
            logger.info("Testing for XSS...")
            xss_vulns = self._test_xss()
            if xss_vulns:
                results['xss'] = xss_vulns
                results['vulnerabilities'].extend(xss_vulns)
            
            # Test for CSRF protection
            logger.info("Testing for CSRF protection...")
            csrf_vulns = self._test_csrf()
            if csrf_vulns:
                results['csrf'] = csrf_vulns
                results['vulnerabilities'].extend(csrf_vulns)
            
            # Test for information disclosure
            logger.info("Testing for information disclosure...")
            info_vulns = self._test_information_disclosure()
            if info_vulns:
                results['other'].extend(info_vulns)
                results['vulnerabilities'].extend(info_vulns)
            
            # Test for directory traversal
            logger.info("Testing for directory traversal...")
            dir_vulns = self._test_directory_traversal()
            if dir_vulns:
                results['other'].extend(dir_vulns)
                results['vulnerabilities'].extend(dir_vulns)
            
            # Calculate score
            results['score'] = self._calculate_vuln_score(results)
            results['summary'] = f"Found {len(results['vulnerabilities'])} vulnerabilities"
            
            return results
            
        except Exception as e:
            logger.error(f"Vulnerability scan error: {str(e)}")
            return {
                'error': str(e),
                'score': 50
            }
    
    def _test_sql_injection(self):
        """Test for SQL injection vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Get the page and find forms/parameters
            response = self.session.get(self.target, timeout=self.timeout)
            soup = BeautifulSoup(response.text, 'html.parser')
            
            # Test URL parameters
            parsed_url = urlparse(self.target)
            params = parse_qs(parsed_url.query)
            
            for param in params:
                for payload in self.SQL_PAYLOADS[:3]:  # Test with first 3 payloads
                    test_params = params.copy()
                    test_params[param] = payload
                    
                    try:
                        test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}"
                        test_response = self.session.get(
                            test_url,
                            params=test_params,
                            timeout=self.timeout
                        )
                        
                        # Check for SQL errors in response
                        for error_pattern in self.SQL_ERRORS:
                            if re.search(error_pattern, test_response.text, re.IGNORECASE):
                                vulnerabilities.append({
                                    'type': 'SQL Injection',
                                    'severity': 'critical',
                                    'parameter': param,
                                    'payload': payload,
                                    'description': f'Possible SQL injection in parameter "{param}"'
                                })
                                break
                    except:
                        continue
            
            # Test forms
            forms = soup.find_all('form')
            for form in forms[:2]:  # Test first 2 forms
                for payload in self.SQL_PAYLOADS[:2]:
                    try:
                        form_data = {}
                        for input_field in form.find_all('input'):
                            name = input_field.get('name')
                            if name:
                                form_data[name] = payload
                        
                        action = form.get('action', '')
                        form_url = urljoin(self.target, action)
                        method = form.get('method', 'get').lower()
                        
                        if method == 'post':
                            test_response = self.session.post(
                                form_url,
                                data=form_data,
                                timeout=self.timeout
                            )
                        else:
                            test_response = self.session.get(
                                form_url,
                                params=form_data,
                                timeout=self.timeout
                            )
                        
                        for error_pattern in self.SQL_ERRORS:
                            if re.search(error_pattern, test_response.text, re.IGNORECASE):
                                vulnerabilities.append({
                                    'type': 'SQL Injection',
                                    'severity': 'critical',
                                    'location': 'form',
                                    'payload': payload,
                                    'description': 'Possible SQL injection in form submission'
                                })
                                break
                    except:
                        continue
                        
        except Exception as e:
            logger.error(f"SQL injection test error: {str(e)}")
        
        return vulnerabilities
    
    def _test_xss(self):
        """Test for XSS vulnerabilities"""
        vulnerabilities = []
        
        try:
            response = self.session.get(self.target, timeout=self.timeout)
            soup = BeautifulSoup(response.text, 'html.parser')
            
            # Test URL parameters
            parsed_url = urlparse(self.target)
            params = parse_qs(parsed_url.query)
            
            for param in params:
                for payload in self.XSS_PAYLOADS[:2]:
                    test_params = params.copy()
                    test_params[param] = payload
                    
                    try:
                        test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}"
                        test_response = self.session.get(
                            test_url,
                            params=test_params,
                            timeout=self.timeout
                        )
                        
                        # Check if payload is reflected in response
                        if payload in test_response.text:
                            vulnerabilities.append({
                                'type': 'Cross-Site Scripting (XSS)',
                                'severity': 'high',
                                'parameter': param,
                                'payload': payload,
                                'description': f'Possible XSS vulnerability in parameter "{param}"'
                            })
                    except:
                        continue
                        
        except Exception as e:
            logger.error(f"XSS test error: {str(e)}")
        
        return vulnerabilities
    
    def _test_csrf(self):
        """Test for CSRF protection"""
        vulnerabilities = []
        
        try:
            response = self.session.get(self.target, timeout=self.timeout)
            soup = BeautifulSoup(response.text, 'html.parser')
            
            forms = soup.find_all('form')
            for form in forms:
                method = form.get('method', 'get').lower()
                
                if method == 'post':
                    # Check for CSRF tokens
                    has_csrf = False
                    csrf_names = ['csrf', 'token', '_token', 'csrf_token', 'authenticity_token']
                    
                    for input_field in form.find_all('input'):
                        name = input_field.get('name', '').lower()
                        if any(csrf_name in name for csrf_name in csrf_names):
                            has_csrf = True
                            break
                    
                    if not has_csrf:
                        vulnerabilities.append({
                            'type': 'Missing CSRF Protection',
                            'severity': 'medium',
                            'location': 'form',
                            'description': 'Form lacks CSRF token protection'
                        })
                        
        except Exception as e:
            logger.error(f"CSRF test error: {str(e)}")
        
        return vulnerabilities
    
    def _test_information_disclosure(self):
        """Test for information disclosure"""
        vulnerabilities = []
        
        try:
            response = self.session.get(self.target, timeout=self.timeout)
            
            # Check for verbose error messages
            if 'Exception' in response.text or 'Traceback' in response.text:
                vulnerabilities.append({
                    'type': 'Information Disclosure',
                    'severity': 'medium',
                    'description': 'Verbose error messages detected'
                })
            
            # Check for exposed credentials in HTML
            patterns = [
                r'password\s*=\s*["\'][^"\']+["\']',
                r'api[_-]?key\s*=\s*["\'][^"\']+["\']',
                r'secret\s*=\s*["\'][^"\']+["\']'
            ]
            
            for pattern in patterns:
                if re.search(pattern, response.text, re.IGNORECASE):
                    vulnerabilities.append({
                        'type': 'Information Disclosure',
                        'severity': 'high',
                        'description': 'Possible credentials or secrets exposed in HTML'
                    })
                    break
                    
        except Exception as e:
            logger.error(f"Information disclosure test error: {str(e)}")
        
        return vulnerabilities
    
    def _test_directory_traversal(self):
        """Test for directory traversal vulnerabilities"""
        vulnerabilities = []
        payloads = ['../etc/passwd', '..\\windows\\system32\\drivers\\etc\\hosts']
        
        try:
            parsed_url = urlparse(self.target)
            params = parse_qs(parsed_url.query)
            
            for param in params:
                for payload in payloads:
                    test_params = params.copy()
                    test_params[param] = payload
                    
                    try:
                        test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}"
                        test_response = self.session.get(
                            test_url,
                            params=test_params,
                            timeout=self.timeout
                        )
                        
                        # Check for common file contents
                        if 'root:' in test_response.text or 'localhost' in test_response.text:
                            vulnerabilities.append({
                                'type': 'Directory Traversal',
                                'severity': 'critical',
                                'parameter': param,
                                'description': f'Possible directory traversal in parameter "{param}"'
                            })
                            break
                    except:
                        continue
                        
        except Exception as e:
            logger.error(f"Directory traversal test error: {str(e)}")
        
        return vulnerabilities
    
    def _calculate_vuln_score(self, results):
        """Calculate security score based on vulnerabilities"""
        score = 100
        
        for vuln in results['vulnerabilities']:
            severity = vuln.get('severity', 'low')
            if severity == 'critical':
                score -= 20
            elif severity == 'high':
                score -= 15
            elif severity == 'medium':
                score -= 10
            else:
                score -= 5
        
        return max(0, score)

